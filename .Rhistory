if (length(available_slots) > 0) {
chosen_slot <- available_slots[1]
assigned <- rbind(assigned, data.frame(time = chosen_slot, governor = row$governor))
used_slots <- c(used_slots, chosen_slot)
} else {
not_assigned <- c(not_assigned, row$governor)
}
}
for (i in seq_len(nrow(day1_sorted))) {
row <- day1[i, ]
# Check tijdslot-kolommen voor deze rij
slot_values <- row[times]
available_slots <- times[as.logical(slot_values)]
# Filter slots die al bezet zijn
available_slots <- setdiff(available_slots, used_slots)
if (length(available_slots) > 0) {
chosen_slot <- available_slots[1]
assigned <- rbind(assigned, data.frame(time = chosen_slot, governor = row$governor))
used_slots <- c(used_slots, chosen_slot)
} else {
not_assigned <- c(not_assigned, row$governor)
}
}
for (i in seq_len(nrow(day1))) {
row <- day1[i, ]
# Check tijdslot-kolommen voor deze rij
slot_values <- row[times]
available_slots <- times[as.logical(slot_values)]
# Filter slots die al bezet zijn
available_slots <- setdiff(available_slots, used_slots)
if (length(available_slots) > 0) {
chosen_slot <- available_slots[1]
assigned <- rbind(assigned, data.frame(time = chosen_slot, governor = row$governor))
used_slots <- c(used_slots, chosen_slot)
} else {
not_assigned <- c(not_assigned, row$governor)
}
}
View(assigned)
View(data)
setwd("C:/Users/mvink/OneDrive/Documents")
# Read data
data <- read.csv("kvk_responses.csv")
colnames(data) <- c("timestamp", "governor", "id", "construction", "truegold",
"c_speedups", "c_times", "research", "r_speedups", "r_times",
"training", "t_speedups", "t_times", "comment")
# Construction schedule (day 1)
day1 <- data %>%
filter(construction == "Yes") %>%
arrange(desc(truegold)) %>%
select(timestamp, governor, id, truegold, c_speedups, c_times)
for (time in times){
pattern <- substr(time, 1, 3)
day1 <- day1 %>%
mutate(!!time := str_detect(c_times, fixed(pattern)))
}
# Read data
data <- read.csv("kvk_responses.csv")
colnames(data) <- c("timestamp", "governor", "id", "construction", "truegold",
"c_speedups", "c_times", "research", "r_speedups", "r_times",
"training", "t_speedups", "t_times", "comment")
# Construction schedule (day 1)
day1 <- data %>%
filter(construction == "Yes") %>%
arrange(desc(truegold)) %>%
select(timestamp, governor, id, truegold, c_speedups, c_times)
for (time in times){
pattern <- substr(time, 1, 3)
day1 <- day1 %>%
mutate(!!time := str_detect(c_times, fixed(pattern)))
}
assigned <- data.frame(time = character(), governor = character(), stringsAsFactors = FALSE)
not_assigned <- c()
used_slots <- character()
for (i in seq_len(nrow(day1))) {
row <- day1[i, ]
available_slots <- setdiff(times[as.logical(row[times])], used_slots)
if (length(available_slots) > 0) {
chosen_slot <- available_slots[1]
assigned <- rbind(assigned, data.frame(time = chosen_slot, governor = row$governor))
used_slots <- c(used_slots, chosen_slot)
} else {
not_assigned <- c(not_assigned, row$governor)
}
}
View(assigned)
construction_schedule <- data.frame(time = times, stringsAsFactors = FALSE) %>%
left_join(assigned, by = "time") %>%
arrange(time)
View(construction_schedule)
?write.csv
write.csv(day1, file="construction.csv")
# Read data
data <- read.csv("kvk_responses_2.csv")
colnames(data) <- c("timestamp", "governor", "id", "construction", "truegold",
"c_speedups", "c_times", "research", "r_speedups", "r_times",
"training", "t_speedups", "t_times", "comment")
# Creating character vector of time slots
hrs <- str_pad(as.character(0:23), width=2, side="left", pad="0")
mins <- c(":00", ":30")
times <- c(t(outer(hrs, mins, paste0)))
# Read data
data <- read.csv("kvk_responses_2.csv")
colnames(data) <- c("timestamp", "governor", "id", "construction", "truegold",
"c_speedups", "c_times", "research", "r_speedups", "r_times",
"training", "t_speedups", "t_times", "comment")
day2 <- data %>%
filter(research == "Yes") %>%
arrange(desc(r_speedups)) %>%
select(timestamp, governor, id, r_speedups, r_times)
for (time in times){
pattern <- substr(time, 1, 3)
day2 <- day2 %>%
mutate(!!time := str_detect(r_times, fixed(pattern)))
}
assigned <- data.frame(time = character(), governor = character(), stringsAsFactors = FALSE)
not_assigned <- c()
used_slots <- character()
for (i in seq_len(nrow(day2))) {
row <- day2[i, ]
available_slots <- setdiff(times[as.logical(row[times])], used_slots)
if (length(available_slots) > 0) {
chosen_slot <- available_slots[1]
assigned <- rbind(assigned, data.frame(time = chosen_slot, governor = row$governor))
used_slots <- c(used_slots, chosen_slot)
} else {
not_assigned <- c(not_assigned, row$governor)
}
}
research_schedule <- data.frame(time = times, stringsAsFactors = FALSE) %>%
left_join(assigned, by = "time") %>%
arrange(time)
View(research_schedule)
View(day2)
# Creating character vector of time slots
hrs <- str_pad(as.character(0:23), width=2, side="left", pad="0")
mins <- c(":00", ":30")
times <- c(t(outer(hrs, mins, paste0)))
# Read data
data <- read.csv("kvk_responses_3.csv")
colnames(data) <- c("timestamp", "governor", "id", "construction", "truegold",
"c_speedups", "c_times", "research", "r_speedups", "r_times",
"training", "t_speedups", "t_times", "comment")
# Construction schedule (day 1)
day1 <- data %>%
filter(construction == "Yes") %>%
arrange(desc(truegold)) %>%
select(timestamp, governor, id, truegold, c_speedups, c_times)
for (time in times){
pattern <- substr(time, 1, 3)
day1 <- day1 %>%
mutate(!!time := str_detect(c_times, fixed(pattern)))
}
assigned <- data.frame(time = character(), governor = character(), stringsAsFactors = FALSE)
not_assigned <- c()
used_slots <- character()
for (i in seq_len(nrow(day1))) {
row <- day1[i, ]
available_slots <- setdiff(times[as.logical(row[times])], used_slots)
if (length(available_slots) > 0) {
chosen_slot <- available_slots[1]
assigned <- rbind(assigned, data.frame(time = chosen_slot, governor = row$governor))
used_slots <- c(used_slots, chosen_slot)
} else {
not_assigned <- c(not_assigned, row$governor)
}
}
construction_schedule <- data.frame(time = times, stringsAsFactors = FALSE) %>%
left_join(assigned, by = "time") %>%
arrange(time)
not_assigned
View(day1)
# Read data
data <- read.csv("kvk_responses_3.csv")
colnames(data) <- c("timestamp", "governor", "id", "construction", "truegold",
"c_speedups", "c_times", "research", "r_speedups", "r_times",
"training", "t_speedups", "t_times", "comment")
# Construction schedule (day 1)
day1 <- data %>%
filter(construction == "Yes") %>%
arrange(desc(truegold)) %>%
select(timestamp, governor, id, truegold, c_speedups, c_times)
for (time in times){
pattern <- substr(time, 1, 3)
day1 <- day1 %>%
mutate(!!time := str_detect(c_times, fixed(pattern)))
}
assigned <- data.frame(time = character(), governor = character(), stringsAsFactors = FALSE)
not_assigned <- c()
used_slots <- character()
for (i in seq_len(nrow(day1))) {
row <- day1[i, ]
available_slots <- setdiff(times[as.logical(row[times])], used_slots)
if (length(available_slots) > 0) {
chosen_slot <- available_slots[1]
assigned <- rbind(assigned, data.frame(time = chosen_slot, governor = row$governor))
used_slots <- c(used_slots, chosen_slot)
} else {
not_assigned <- c(not_assigned, row$governor)
}
}
construction_schedule <- data.frame(time = times, stringsAsFactors = FALSE) %>%
left_join(assigned, by = "time") %>%
arrange(time)
not_assigned
# Creating character vector of time slots
hrs <- str_pad(as.character(0:23), width=2, side="left", pad="0")
mins <- c(":00", ":30")
times <- c(t(outer(hrs, mins, paste0)))
# Read data
data <- read.csv("kvk_responses_3.csv")
colnames(data) <- c("timestamp", "governor", "id", "construction", "truegold",
"c_speedups", "c_times", "research", "r_speedups", "r_times",
"training", "t_speedups", "t_times", "comment")
day2 <- data %>%
filter(research == "Yes") %>%
arrange(desc(r_speedups)) %>%
select(timestamp, governor, id, r_speedups, r_times)
for (time in times){
pattern <- substr(time, 1, 3)
day2 <- day2 %>%
mutate(!!time := str_detect(r_times, fixed(pattern)))
}
assigned <- data.frame(time = character(), governor = character(), stringsAsFactors = FALSE)
not_assigned <- c()
used_slots <- character()
for (i in seq_len(nrow(day2))) {
row <- day2[i, ]
available_slots <- setdiff(times[as.logical(row[times])], used_slots)
if (length(available_slots) > 0) {
chosen_slot <- available_slots[1]
assigned <- rbind(assigned, data.frame(time = chosen_slot, governor = row$governor))
used_slots <- c(used_slots, chosen_slot)
} else {
not_assigned <- c(not_assigned, row$governor)
}
}
research_schedule <- data.frame(time = times, stringsAsFactors = FALSE) %>%
left_join(assigned, by = "time") %>%
arrange(time)
View(research_schedule)
View(day2)
# Maak een rooster met alle 48 slots
rooster <- data.frame(time = times, governor = NA_character_, stringsAsFactors = FALSE)
for (i in seq_len(nrow(assigned))) {
rooster$governor[rooster$time == assigned$time[i]] <- assigned$governor[i]
}
View(rooster)
# Herverdeel om zoveel mogelijk not_assigned toch in te plannen
for (na_user in not_assigned) {
# Vind de rij in day1
row <- day2[day2$governor == na_user, ]
possible_slots <- times[as.logical(row[times])]
placed <- FALSE
for (slot in possible_slots) {
current_gov <- rooster$governor[rooster$time == slot]
if (is.na(current_gov)) {
rooster$governor[rooster$time == slot] <- na_user
placed <- TRUE
break
} else {
row2 <- day2[day2$governor == current_gov, ]
alt_slots <- times[as.logical(row2[times])]
empty_alts <- setdiff(alt_slots, rooster$time[!is.na(rooster$governor)])
if (length(empty_alts) > 0) {
rooster$governor[rooster$time == empty_alts[1]] <- current_gov
rooster$governor[rooster$time == slot] <- na_user
placed <- TRUE
break
}
}
}
if (placed) {
not_assigned <- setdiff(not_assigned, na_user)  # haal eruit als hij een plek kreeg
}
}
View(rooster)
library(dplyr)
# Creating character vector of time slots
hrs <- str_pad(as.character(0:23), width=2, side="left", pad="0")
mins <- c(":00", ":30")
times <- c(t(outer(hrs, mins, paste0)))
# Read data
data <- read.csv("kvk_responses_3.csv")
colnames(data) <- c("timestamp", "governor", "id", "construction", "truegold",
"c_speedups", "c_times", "research", "r_speedups", "r_times",
"training", "t_speedups", "t_times", "comment")
day2 <- data %>%
filter(research == "Yes") %>%
arrange(desc(r_speedups)) %>%
select(timestamp, governor, id, r_speedups, r_times)
make_schedule <- function(data, times, max_chain = 1) {
# First iteration: greedy assignment
assigned <- data.frame(time = character(), governor = character(), stringsAsFactors = FALSE)
used_slots <- character()
not_assigned <- c()
for (i in seq_len(nrow(data))) {
row <- data[i, ]
slot_values <- row[times]
available_slots <- times[as.logical(slot_values)]
available_slots <- setdiff(available_slots, used_slots)
if (length(available_slots) > 0) {
chosen_slot <- available_slots[1]
assigned <- rbind(assigned, data.frame(time = chosen_slot, governor = row$governor))
used_slots <- c(used_slots, chosen_slot)
} else {
not_assigned <- c(not_assigned, row$governor)
}
}
schedule <- data.frame(time = times, governor = NA_character_, stringsAsFactors = FALSE)
for (i in seq_len(nrow(assigned))) {
schedule$governor[schedule$time == assigned$time[i]] <- assigned$governor[i]
}
try_place <- function(user, chain_depth, schedule, not_assigned) {
row <- data[data$governor == user, ]
possible_slots <- times[as.logical(row[times])]
for (slot in possible_slots) {
current_gov <- schedule$governor[schedule$time == slot]
if (is.na(current_gov)) {
schedule$governor[schedule$time == slot] <- user
return(list(success = TRUE, schedule = schedule, not_assigned = setdiff(not_assigned, user)))
} else if (chain_depth < max_chain) {
result <- try_place(current_gov, chain_depth + 1, schedule, not_assigned)
if (result$success) {
schedule <- result$schedule
not_assigned <- result$not_assigned
schedule$governor[schedule$time == slot] <- user
return(list(success = TRUE, schedule = schedule, not_assigned = setdiff(not_assigned, user)))
}
}
}
return(list(success = FALSE, schedule = schedule, not_assigned = not_assigned))
}
# Try to assign unassigned users
for (user in not_assigned) {
result <- try_place(user, chain_depth = 0, schedule, not_assigned)
schedule <- result$schedule
not_assigned <- result$not_assigned
}
return(list(schedule = schedule, not_assigned = not_assigned))
}
research_schedule <- make_schedule(day2, times)
research_schedule <- make_schedule(day2, times)
research_schedule <- make_schedule(day2, times)
row
row <- day2[1, ]
row[times]
day2 <- data %>%
filter(research == "Yes") %>%
arrange(desc(r_speedups)) %>%
select(timestamp, governor, id, r_speedups, r_times) %>%
rename(times = r_times)
row <- day2[1, ]
row[times]
row$times
hrs <- str_pad(as.character(0:23), width=2, side="left", pad="0")
mins <- c(":00", ":30")
times <- c(t(outer(hrs, mins, paste0)))
# Read data
data <- read.csv("kvk_responses_3.csv")
colnames(data) <- c("timestamp", "governor", "id", "construction", "truegold",
"c_speedups", "c_times", "research", "r_speedups", "r_times",
"training", "t_speedups", "t_times", "comment")
day2 <- data %>%
filter(research == "Yes") %>%
arrange(desc(r_speedups)) %>%
select(timestamp, governor, id, r_speedups, r_times)
for (time in times){
pattern <- substr(time, 1, 3)
day2 <- day2 %>%
mutate(!!time := str_detect(r_times, fixed(pattern)))
}
assigned <- data.frame(time = character(), governor = character(), stringsAsFactors = FALSE)
not_assigned <- c()
used_slots <- character()
for (i in seq_len(nrow(day2))) {
row <- day2[i, ]
available_slots <- setdiff(times[as.logical(row[times])], used_slots)
if (length(available_slots) > 0) {
chosen_slot <- available_slots[1]
assigned <- rbind(assigned, data.frame(time = chosen_slot, governor = row$governor))
used_slots <- c(used_slots, chosen_slot)
} else {
not_assigned <- c(not_assigned, row$governor)
}
}
research_schedule <- data.frame(time = times, stringsAsFactors = FALSE) %>%
left_join(assigned, by = "time") %>%
arrange(time)
# Try to assign not_assigned users
for (na_user in not_assigned) {
row <- day2[day2$governor == na_user, ]
possible_slots <- times[as.logical(row[times])]
placed <- FALSE
for (slot in possible_slots) {
current_gov <- rooster$governor[rooster$time == slot]
if (is.na(current_gov)) {
rooster$governor[rooster$time == slot] <- na_user
placed <- TRUE
break
} else {
row2 <- day2[day2$governor == current_gov, ]
alt_slots <- times[as.logical(row2[times])]
empty_alts <- setdiff(alt_slots, rooster$time[!is.na(rooster$governor)])
if (length(empty_alts) > 0) {
rooster$governor[rooster$time == empty_alts[1]] <- current_gov
rooster$governor[rooster$time == slot] <- na_user
placed <- TRUE
break
}
}
}
if (placed) {
not_assigned <- setdiff(not_assigned, na_user)
}
}
# Try to assign not_assigned users
for (na_user in not_assigned) {
row <- day2[day2$governor == na_user, ]
possible_slots <- times[as.logical(row[times])]
placed <- FALSE
for (slot in possible_slots) {
current_gov <- research_schedule$governor[research_schedule$time == slot]
if (is.na(current_gov)) {
research_schedule$governor[research_schedule$time == slot] <- na_user
placed <- TRUE
break
} else {
row2 <- day2[day2$governor == current_gov, ]
alt_slots <- times[as.logical(row2[times])]
empty_alts <- setdiff(alt_slots, research_schedule$time[!is.na(research_schedule$governor)])
if (length(empty_alts) > 0) {
research_schedule$governor[research_schedule$time == empty_alts[1]] <- current_gov
research_schedule$governor[research_schedule$time == slot] <- na_user
placed <- TRUE
break
}
}
}
if (placed) {
not_assigned <- setdiff(not_assigned, na_user)
}
}
# Try to assign not_assigned users
for (na_user in not_assigned) {
row <- day2[day2$governor == na_user, ]
possible_slots <- times[as.logical(row[times])]
placed <- FALSE
for (slot in possible_slots) {
current_gov <- research_schedule$governor[research_schedule$time == slot]
if (is.na(current_gov)) {
research_schedule$governor[research_schedule$time == slot] <- na_user
placed <- TRUE
break
} else {
row2 <- day2[day2$governor == current_gov, ]
alt_slots <- times[as.logical(row2[times])]
empty_alts <- setdiff(alt_slots, research_schedule$time[!is.na(research_schedule$governor)])
if (length(empty_alts) > 0) {
research_schedule$governor[research_schedule$time == empty_alts[1]] <- current_gov
research_schedule$governor[research_schedule$time == slot] <- na_user
placed <- TRUE
break
}
}
}
if (placed) {
not_assigned <- setdiff(not_assigned, na_user)
}
}
View(day2)
View(research_schedule)
write.csv(day2, file="day2.csv")
library(npregfast)
install.packages("npregfast")
library(npregfast)
data(children)
data <- data(children)
View(children)
write.csv(children, file="kids_height.csv")
library(faraway)
install.packages("faraway")
library(faraway)
data(oatvar)
write.csv(oatvar, file="oatvar.csv")
data <- read.csv("target-data/latest-hospital_admissions.csv")
data <- read.csv("../target-data/latest-hospital_admissions.csv")
setwd("C:/Users/mvink/Documents/Git_repos/RespiCast-Covid19")
data <- read.csv("target-data/latest-hospital_admissions.csv")
View(data)
install.packages("forecast")
library(dplyr)
library(forecast)
?as.Date
data <- read.csv("target-data/latest-hospital_admissions.csv") %>%
mutate(location = as.factor(location),
truth_date = as.Date(truth_date, format="%Y-%M-%D"))
data <- read.csv("target-data/latest-hospital_admissions.csv") %>%
mutate(location = as.factor(location),
truth_date = as.Date(truth_date, format="%Y-%m-%d"))
data_nest <- data %>%
group_by(location) %>%
nest()
library(tidyverse)
install.packages("tidyverse")
data <- read.csv("target-data/latest-hospital_admissions.csv") %>%
mutate(location = as.factor(location),
truth_date = as.Date(truth_date, format="%Y-%m-%d"))
data_nest <- data %>%
group_by(location) %>%
nest()
library(tidyverse)
